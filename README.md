# MFAO Barbershop

MFAO Barbershop — это CRM-система для управления барбершопом, предназначенная для автоматизации процессов, таких как запись клиентов, управление услугами и авторизация пользователей. Проект реализован в формате монорепозитория, включающего фронтенд на Next.js, бэкенд на NestJS и базу данных PostgreSQL. Для обеспечения высокого качества кода используются инструменты Husky, Commitlint и ESLint, а для контейнеризации — Docker с оркестрацией через Docker Compose. Yarn Workspaces управляет зависимостями, а формат веток и коммитов строго регламентирован для интеграции с тикетами (например, MFAO-1 для авторизации через Telegram).

Проект подходит для разработчиков, желающих внести вклад в создание современной CRM-системы, а также для изучения работы с монорепозиториями, контейнеризацией и современными инструментами разработки.

## Оглавление
1. [Стек технологий](#стек-технологий)
2. [Установка](#установка)
   - [Требования](#требования)
   - [Локальная установка](#локальная-установка)
   - [Запуск через Docker](#запуск-через-docker)
3. [Структура проекта](#структура-проекта)
4. [Работа с Git](#работа-с-git)
   - [Формат веток](#формат-веток)
   - [Формат коммитов](#формат-коммитов)
   - [Пуш и Pull Request](#пуш-и-pull-request)
5. [Линтинг и форматирование](#линтинг-и-форматирование)
6. [Тестирование](#тестирование)
7. [CI/CD](#cicd)
8. [Текущие задачи](#текущие-задачи)
9. [Проблемы и поддержка](#проблемы-и-поддержка)
10. [Планы](#планы)

## Стек технологий

### Фронтенд
- **Next.js** (15.3.1): React-фреймворк для серверного рендеринга, статической генерации и динамических маршрутов. Обеспечивает высокую производительность и SEO-оптимизацию.
- **React** (19.0.0): Библиотека для построения компонентного интерфейса.
- **TypeScript**: Статическая типизация для повышения надёжности кода.
- **Tailwind CSS**: Утилитарный CSS-фреймворк для быстрого создания стилей.
- **Jest**: Фреймворк для модульного тестирования компонентов и логики.
- **Cypress**: Инструмент для UI-тестирования, обеспечивающий проверку пользовательских сценариев.

### Бэкенд
- **NestJS** (10.x): Прогрессивный Node.js-фреймворк для создания масштабируемых серверных приложений с поддержкой TypeScript.
- **Prisma** (5.x): ORM для удобной работы с PostgreSQL, включая миграции и запросы.
- **PostgreSQL** (15): Мощная реляционная база данных для хранения данных о клиентах, услугах и записях.

### Инфраструктура и инструменты
- **Yarn Workspaces** (1.22.19): Централизованное управление зависимостями в монорепозитории, единый `yarn.lock` в корне.
- **Docker**: Контейнеризация фронтенда (порт 3000), бэкенда (порт 5050) и PostgreSQL (порт 8080 на хосте, 5432 в контейнере).
- **Docker Compose**: Оркестрация контейнеров для упрощения запуска и управления.
- **Husky** (9.1.7): Git-хуки для автоматического линтинга, форматирования и проверки коммитов.
- **Commitlint** (19.8.0): Проверка формата коммитов для соответствия стандарту `<type> [MF-XX]: <description>`.
- **ESLint** (8.57.1): Линтинг кода для TypeScript и React.
- **Prettier** (3.3.3): Автоматическое форматирование кода.
- **Git**: Контроль версий с форматом веток `feature/MF-XX`.

## Установка

### Требования
Перед началом работы убедитесь, что у вас установлены следующие инструменты:
- **Node.js**: v22.12.0 (рекомендуется использовать [nvm](https://github.com/nvm-sh/nvm) для управления версиями).
- **Yarn**: v1.22.19 (`npm install -g yarn`).
- **Docker** и **Docker Compose**: Для запуска в контейнерах (см. [инструкции по установке](https://docs.docker.com/get-docker/)).
- **Git**: Для работы с репозиторием.
- Операционная система: macOS, Linux или Windows (с WSL2 для Docker).

### Локальная установка
Следуйте этим шагам, чтобы запустить проект локально:

1. **Клонируйте репозиторий**:
   ```bash
   git clone <repository-url>
   cd MFAO_barbershop
   ```

2. **Установите зависимости**:
   Выполните команду в корне проекта, чтобы установить зависимости для `frontend` и `backend` с помощью Yarn Workspaces:
   ```bash
   yarn install
   ```
   Это создаст или обновит корневой `yarn.lock` и установит зависимости в папку `node_modules`.

3. **Настройте окружение**:
   - Скопируйте пример файла окружения для бэкенда:
     ```bash
     cp backend/.env.example backend/.env
     ```
   - Откройте `backend/.env` в текстовом редакторе и задайте следующие переменные:
     ```env
     PORT=5050
     DATABASE_URL=postgresql://user:password@localhost:8080/barber_app?schema=public
     ```
   - Убедитесь, что локальный PostgreSQL-сервер работает на порту 8080. Если порт отличается, обновите `DATABASE_URL`.

4. **Настройте базу данных**:
   - Установите PostgreSQL локально, если ещё не установлен (например, через Homebrew на macOS: `brew install postgresql`).
   - Создайте базу данных `barber_app`:
     ```bash
     psql -U <your-user> -c "CREATE DATABASE barber_app;"
     ```
   - Примените миграции Prisma для создания таблиц:
     ```bash
     cd backend
     npx prisma migrate dev --name init
     ```

5. **Запустите фронтенд и бэкенд**:
   - В корне проекта выполните:
     ```bash
     yarn frontend:dev  # Запускает Next.js на http://localhost:3000
     yarn backend:dev   # Запускает NestJS на http://localhost:5050
     ```
   - Откройте браузер:
     - Фронтенд: http://localhost:3000
     - Бэкенд: http://localhost:5050 (для проверки API).

### Запуск через Docker
Docker позволяет запустить проект в контейнерах, упрощая настройку окружения.

1. **Убедитесь, что Docker и Docker Compose установлены**:
   ```bash
   docker --version
   docker-compose --version
   ```

2. **Проверьте доступность портов**:
   Убедитесь, что порты 3000 (фронтенд), 5050 (бэкенд) и 8080 (PostgreSQL) свободны:
   ```bash
   lsof -i :3000
   lsof -i :5050
   lsof -i :8080
   ```
   Если порты заняты, остановите процессы:
   ```bash
   kill -9 <PID>
   ```

3. **Запустите контейнеры**:
   Выполните команду в корне проекта:
   ```bash
   docker-compose up -d --build
   ```
   - Флаг `--build` пересобирает образы.
   - Флаг `-d` запускает контейнеры в фоновом режиме.

4. **Проверьте доступ**:
   - Фронтенд: http://localhost:3000
   - Бэкенд: http://localhost:5050
   - PostgreSQL: подключитесь через клиент, например:
     ```bash
     psql -h localhost -p 8080 -U user -d barber_app
     ```
     Пароль: `password` (или тот, что указан в `backend/.env`).

5. **Остановите контейнеры**:
   Когда работа завершена, остановите контейнеры:
   ```bash
   docker-compose down
   ```

6. **Очистка (при необходимости)**:
   Если нужно удалить образы или кэш:
   ```bash
   docker-compose down --rmi all
   docker builder prune
   ```

## Структура проекта

Проект организован как монорепозиторий с чёткой структурой:

- **`backend/`**: Бэкенд на NestJS.
  - `src/`: Исходный код (модули, контроллеры, сервисы).
  - `prisma/`: Схема базы данных (`schema.prisma`) и миграции.
  - `package.json`: Зависимости бэкенда.
  - `.env.example`: Шаблон файла окружения.
  - `test/`: E2E-тесты для API.

- **`frontend/`**: Фронтенд на Next.js.
  - `src/`: Исходный код (страницы, компоненты, хуки).
  - `public/`: Статические файлы (изображения, шрифты).
  - `package.json`: Зависимости фронтенда.
  - `cypress/`: UI-тесты для Cypress.

- **`docker-compose.yml`**: Конфигурация Docker для запуска фронтенда (порт 3000), бэкенда (порт 5050) и PostgreSQL (порт 8080:5432).

- **`.husky/`**: Git-хуки для автоматического линтинга, форматирования и проверки коммитов.

- **`commitlint.config.js`**: Правила для формата коммитов (`<type> [MF-XX]: <description>`).

- **`.eslintrc.js`**: Конфигурация ESLint для TypeScript и React.

- **`.prettierrc`**: Настройки Prettier для форматирования кода.

- **`yarn.lock`**: Единый файл зависимостей для Yarn Workspaces, расположен в корне.

- **`package.json`**: Корневой файл с настройками Yarn Workspaces и глобальными скриптами.

- **`.gitignore`**: Исключает временные файлы (`node_modules`, `.next`, `dist`, `.env`).

- **`check-branch-name.sh`**: Скрипт для проверки формата веток (`feature/MF-XX`).

## Работа с Git

### Формат веток
Проект использует структурированный подход к ветвлению, который в будущем будет расширен с помощью Git Flow.

- **Основные ветки**:
  - `main`: Содержит стабильный код для продакшена.
  - `develop`: Интеграционная ветка для новых фич и исправлений.

- **Фичи**:
  - Создавайте ветки в формате `feature/MF-XX`, где `XX` — номер тикета (например, `feature/MF-1` для тикета MFAO-1).
  - Пример создания ветки:
    ```bash
    git checkout develop
    git checkout -b feature/MF-1
    ```

- **Будущие ветки (с Git Flow)**:
  - `release/*`: Для подготовки релизов (например, `release/1.0.0`).
  - `hotfix/*`: Для срочных исправлений в продакшене (например, `hotfix/1.0.1`).

- **Переименование ветки** (если ошиблись с номером тикета):
  ```bash
  git branch -m feature/MF-1 feature/MF-2
  git push origin --delete feature/MF-1
  git push origin feature/MF-2
  ```

### Формат коммитов
Коммиты должны соответствовать стандарту, проверяемому Commitlint через Husky.

- **Формат**: `<type> [MF-XX]: <Description>`
  - `<type>`: Тип изменения (`feature`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`, `revert`).
  - `[MF-XX]`: Номер тикета (например, `[MF-1]` для MFAO-1).
  - `<Description>`: Краткое описание с заглавной буквы (sentence-case, например, `Configure docker`).
- **Примеры**:
  ```bash
  feat [MF-1]: Add Telegram auth endpoint
  fix [MF-2]: Resolve login validation error
  chore [MF-0]: Configure docker and update Husky hooks
  docs [MF-0]: Update README with installation guide
  ```

- **Создание коммита**:
  ```bash
  git add .
  git commit -m "chore [MF-0]: Configure docker"
  ```

- **Исправление коммита** (если Commitlint отклонил):
  Если сообщение не прошло проверку (например, из-за отсутствия заглавной буквы):
  ```bash
  git commit --amend -m "chore [MF-0]: Configure docker"
  ```

### Пуш и Pull Request
1. **Запушьте изменения** в свою ветку:
   ```bash
   git push origin feature/MF-1
   ```

2. **Создайте Pull Request (PR)**:
   - В репозитории (например, GitHub/GitLab) создайте PR:
     - **Базовая ветка**: `develop`.
     - **Исходная ветка**: `feature/MF-1`.
   - Добавьте описание PR, указав тикет (например, `MFAO-1`) и изменения.
   - Убедитесь, что CI/CD (если настроено) проходит успешно.

3. **Разрешите конфликты** (если они есть):
   ```bash
   git checkout develop
   git pull origin develop
   git checkout feature/MF-1
   git rebase develop
   ```
   Если возникли конфликты, исправьте их в редакторе, затем:
   ```bash
   git rebase --continue
   git push --force
   ```

## Линтинг и форматирование

Для поддержания качества кода используются ESLint и Prettier, интегрированные с Husky для автоматической проверки перед коммитами.

- **Линтинг**:
  ```bash
  yarn lint        # Проверяет код на ошибки
  yarn lint:fix    # Автоматически исправляет ошибки
  ```

- **Форматирование**:
  ```bash
  yarn format      # Форматирует код с помощью Prettier
  yarn format:check # Проверяет форматирование
  ```

- **Husky и lint-staged**:
  Перед каждым коммитом Husky запускает `lint-staged`, который проверяет только изменённые файлы (`*.ts`, `*.tsx`) с помощью ESLint и Prettier. Если проверки не проходят, коммит отклоняется.

## Тестирование

Проект включает модульные, интеграционные и UI-тесты для обеспечения надёжности.

### Фронтенд
- **Модульные тесты (Jest)**:
  ```bash
  yarn test        # Запускает все тесты
  yarn test:watch  # Интерактивный режим для разработки
  ```
  Тесты расположены в `frontend/__tests__` или рядом с компонентами (например, `Component.test.tsx`).

- **UI-тесты (Cypress)**:
  ```bash
  yarn cypress:open  # Открывает интерфейс Cypress
  yarn cypress:run   # Запускает тесты в терминале
  ```
  Тесты находятся в `frontend/cypress/`.

### Бэкенд
- **E2E-тесты**:
  ```bash
  cd backend
  yarn test:e2e
  ```
  Тесты расположены в `backend/test/` и проверяют API-эндпоинты.

## CI/CD

В настоящее время CI/CD не настроен, но в планах:
- Создание пайплайна с GitHub Actions или GitLab CI для:
  - Автоматического линтинга и тестирования (`yarn lint`, `yarn test`).
  - Сборки Docker-образов.
  - Деплоя на Oracle Cloud Free Tier.
- Использование `.env.example` для CI/CD:
  - Файл `backend/.env.example` содержит шаблон переменных:
    ```env
    PORT=5050
    DATABASE_URL=postgresql://user:password@db:5432/barber_app?schema=public
    ```
  - Убедитесь, что CI/CD-система имеет доступ к этим переменным через секреты.

**Пример настройки CI/CD** (будет добавлен в будущем):
- Создать `.github/workflows/ci.yml`:
  ```yaml
  name: CI
  on:
    push:
      branches: [main, develop]
    pull_request:
      branches: [main, develop]
  jobs:
    build-and-test:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v3
        - uses: actions/setup-node@v3
          with:
            node-version: '22'
        - run: yarn install
        - run: yarn lint
        - run: yarn test
  ```

## Текущие задачи
- **MFAO-1**: Реализация авторизации через Telegram для пользователей.
  - Создание эндпоинта на бэкенде для обработки Telegram OAuth.
  - Интеграция с фронтендом для отображения кнопки логина.
- Настройка Git Flow для структурированного ветвления (`feature/*`, `release/*`, `hotfix/*`).
- Настройка CI/CD для автоматического тестирования и деплоя на Oracle Cloud.

## Проблемы и поддержка
Если вы столкнулись с проблемами, проверьте следующие аспекты:
- **Порты заняты**:
  ```bash
  lsof -i :3000
  lsof -i :5050
  lsof -i :8080
  kill -9 <PID>
  ```
- **Зависимости не синхронизированы**:
  ```bash
  yarn install
  ```
- **Ошибка миграций Prisma**:
  ```bash
  cd backend
  npx prisma migrate dev --name init
  ```
- **Логи Docker**:
  ```bash
  docker logs mfao_barbershop-frontend-1
  docker logs mfao_barbershop-backend-1
  ```

Для багов или вопросов:
- Создайте issue в репозитории с подробным описанием проблемы.
- Проверьте логи и приложите их к issue.
- Обратитесь в канал разработки (если доступен).

## Планы
- Внедрить Git Flow для упрощения релизов и хотфиксов.
- Настроить CI/CD с автоматическим тестированием и деплоем на Oracle Cloud Free Tier.
- Реализовать тикет MFAO-1 (авторизация через Telegram).
- Добавить больше модульных и e2e-тестов для фронтенда и бэкенда.
- Оптимизировать производительность фронтенда (ленивая загрузка, сжатие изображений в WebP).
- Улучшить документацию, добавив примеры API-эндпоинтов и сценариев использования.